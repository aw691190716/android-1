diff --git a/include/cutils/iosched_policy.h b/include/cutils/iosched_policy.h
index 07c5d1f..25b87ba 100644
--- a/include/cutils/iosched_policy.h
+++ b/include/cutils/iosched_policy.h
@@ -31,6 +31,8 @@ typedef enum {
 extern int android_set_ioprio(int pid, IoSchedClass clazz, int ioprio);
 extern int android_get_ioprio(int pid, IoSchedClass *clazz, int *ioprio);
 
+extern int android_set_rt_ioprio(int pid, int rt);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/init/devices.cpp b/init/devices.cpp
index cffc561..f00216a 100644
--- a/init/devices.cpp
+++ b/init/devices.cpp
@@ -331,6 +331,35 @@ static void remove_platform_device(const char *path)
     }
 }
 
+/* Given a path that may start with an MTD device (/devices/virtual/mtd/mtd8/mtdblock8),
+ * populate the supplied buffer with the MTD partition number and return 0.
+ * If it doesn't start with an MTD device, or there is some error, return -1 */
+static int find_mtd_device_prefix(const char *path, char *buf, ssize_t buf_sz)
+{
+    const char *start, *end;
+
+    if (strncmp(path, "/devices/virtual/mtd", 20))
+        return -1;
+
+    /* Beginning of the prefix is the initial "mtdXX" after "/devices/virtual/mtd/" */
+    start = path + 21;
+
+    /* End of the prefix is one path '/' later, capturing the partition number
+     * Example: mtd8 */
+    end = strchr(start, '/');
+    if (!end) {
+        return -1;
+    }
+
+    /* Make sure we have enough room for the string plus null terminator */
+    if (end - start + 1 > buf_sz)
+        return -1;
+
+    strncpy(buf, start, end - start);
+    buf[end - start] = '\0';
+    return 0;
+}
+
 /* Given a path that may start with a PCI device, populate the supplied buffer
  * with the PCI domain/bus number and the peripheral ID and return 0.
  * If it doesn't start with a PCI device, or there is some error, return -1 */
@@ -480,6 +509,10 @@ static char **get_block_device_symlinks(struct uevent *uevent)
     char link_path[256];
     int link_num = 0;
     char *p;
+    int mtd_fd = -1;
+    int nr;
+    char mtd_name_path[256];
+    char mtd_name[64];
 
     pdev = find_platform_device(uevent->path);
     if (pdev) {
@@ -488,19 +521,45 @@ static char **get_block_device_symlinks(struct uevent *uevent)
     } else if (!find_pci_device_prefix(uevent->path, buf, sizeof(buf))) {
         device = buf;
         type = "pci";
+    } else if (!find_mtd_device_prefix(uevent->path, buf, sizeof(buf))) {
+        device = buf;
+        type = "mtd";
     } else {
         return NULL;
     }
 
-    char **links = (char**) malloc(sizeof(char *) * 4);
+    char **links = (char**) malloc(sizeof(char *) * 6);
     if (!links)
         return NULL;
-    memset(links, 0, sizeof(char *) * 4);
+    memset(links, 0, sizeof(char *) * 6);
 
     INFO("found %s device %s\n", type, device);
 
     snprintf(link_path, sizeof(link_path), "/dev/block/%s/%s", type, device);
 
+    if(!strcmp(type, "mtd")) {
+        snprintf(mtd_name_path, sizeof(mtd_name_path),
+            "/sys/devices/virtual/%s/%s/name", type, device);
+        mtd_fd = open(mtd_name_path, O_RDONLY);
+            if(mtd_fd < 0) {
+                ERROR("Unable to open %s for reading", mtd_name_path);
+                return NULL;
+            }
+        nr = read(mtd_fd, mtd_name, sizeof(mtd_name) - 1);
+        if (nr <= 0)
+            return NULL;
+        close(mtd_fd);
+        mtd_name[nr - 1] = '\0';
+
+        p = strdup(mtd_name);
+        sanitize(p);
+        if (asprintf(&links[link_num], "/dev/block/%s/by-name/%s", type, p) > 0)
+            link_num++;
+        else
+            links[link_num] = NULL;
+        free(p);
+    }
+
     if (uevent->partition_name) {
         p = strdup(uevent->partition_name);
         sanitize(p);
diff --git a/init/init.cpp b/init/init.cpp
index 84da2b9..e394f19 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -321,6 +321,9 @@ static int set_mmap_rnd_bits_action(const std::vector<std::string>& args)
         ret = 0;
     }
 #elif defined(__arm__) || defined(__i386__)
+#ifdef NOTSET_MMAP_RND_BITS_ACTION
+    return 0;
+#endif
     /* check to see if we're running on 64-bit kernel */
     bool h64 = !access(MMAP_RND_COMPAT_PATH, F_OK);
     /* supported 32-bit architecture must have 16 bits set */
@@ -402,6 +405,8 @@ static void import_kernel_nv(const std::string& key, const std::string& value, b
     } else if (android::base::StartsWith(key, "androidboot.")) {
         property_set(android::base::StringPrintf("ro.boot.%s", key.c_str() + 12).c_str(),
                      value.c_str());
+    } else if (key == "serialno") {
+        property_set(android::base::StringPrintf("ro.boot.%s", key.c_str()).c_str(), value.c_str());
     }
 }
 
diff --git a/libcutils/iosched_policy.c b/libcutils/iosched_policy.c
index 71bc94b..2bcc972 100644
--- a/libcutils/iosched_policy.c
+++ b/libcutils/iosched_policy.c
@@ -56,3 +56,8 @@ int android_get_ioprio(int pid __android_unused, IoSchedClass *clazz, int *iopri
 #endif
     return 0;
 }
+
+int android_set_rt_ioprio(int tid, int rt) {
+    printf("android_set_rt_ioprio tid=%d,rt=%d\n", tid, rt);
+    return -1;
+}
